package model_test

import (
	"errors"
	"testing"
	"time"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/mystardustcaptain/mattodo/pkg/model"
	"github.com/stretchr/testify/assert"
)

// TestGetAllTodoItems_ExecuteCorrectQuery tests that GetAllTodoItems executes the correct query,
// returns the correct number of TodoItems,
// and returns the correct TodoItems data,
// and handle errors correctly.
func TestGetAllTodoItems_ExecuteCorrectQuery(t *testing.T) {
	/// Arrange
	///
	// Create a new instance of sqlmock
	db, mock, errdb := sqlmock.New()
	if errdb != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", errdb)
	}
	defer db.Close()

	columns := []string{"id", "user_id", "title", "completed", "created_at", "updated_at"}
	mock.ExpectQuery("SELECT id, user_id, title, completed, created_at, updated_at FROM todos WHERE user_id = ?").
		WithArgs(2).
		WillReturnRows(sqlmock.NewRows(columns).
			AddRow(2, 2, "Todo 2", false, time.Now(), time.Now()).
			AddRow(3, 2, "Todo 3", false, time.Now(), time.Now()))

	tc := model.TodoItemCollection{DB: db}

	/// Act
	///
	// call GetAllTodoItems on user id 2
	todos, err := tc.GetAllTodoItems(2)
	if err != nil {
		t.Errorf("error was not expected while getting todo items: %s", err)
	}

	/// Assert
	///
	assert.Equal(t, 2, len(todos))
	assert.NoError(t, err, "Expected no error but got one")
	assert.Equal(t, 2, todos[0].ID)
	assert.Equal(t, 2, todos[0].UserID)
	assert.Equal(t, "Todo 2", todos[0].Title)
	assert.Equal(t, false, todos[0].Completed)
	assert.Equal(t, 3, todos[1].ID)
	assert.Equal(t, 2, todos[1].UserID)
	assert.Equal(t, "Todo 3", todos[1].Title)
	assert.Equal(t, false, todos[1].Completed)

	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}
}

// TestGetAllTodoItems_ReturnNothingWhenNoTodoItems tests that GetAllTodoItems returns nothing when there are error with the query.
// It is to ensure that the error is handled correctly,
// and that the function does not return any TodoItems,
// and that the error is the expected error.
func TestGetAllTodoItems_ReturnNothingWhenQueryError(t *testing.T) {
	/// Arrange
	///
	// Create a new instance of sqlmock
	db, mock, errdb := sqlmock.New()
	if errdb != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", errdb)
	}
	defer db.Close()

	// Define a custom error
	customErr := errors.New("mock database connection error")

	mock.ExpectQuery("SELECT id, user_id, title, completed, created_at, updated_at FROM todos WHERE user_id = ?").
		WithArgs(2).
		WillReturnError(customErr)

	tc := model.TodoItemCollection{DB: db}

	/// Act
	///
	// call GetAllTodoItems on user id 2
	todos, err := tc.GetAllTodoItems(2)

	/// Assert
	///
	assert.Error(t, err, "Expected an error but got none")
	assert.Equal(t, customErr, err, "Expected a different error")
	assert.Nil(t, todos, "Expected todos to be nil on error")

	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}
}

// TestGetAllTodoItems_ReturnNothingWhenScanError tests that GetAllTodoItems returns nothing when there are error during scanning rows.
// It is to ensure that the error is handled correctly,
// and that the function does not return any TodoItems,
// and that the error is the expected error.
func TestGetAllTodoItems_ReturnNothingWhenScanError(t *testing.T) {
	/// Arrange
	// Create a new instance of sqlmock
	db, mock, errdb := sqlmock.New()
	if errdb != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", errdb)
	}
	defer db.Close()

	// Define a custom error
	customErr := errors.New("sql: Scan error on column index 5, name \"updated_at\": unsupported Scan, storing driver.Value type string into type *time.Time")

	columns := []string{"id", "user_id", "title", "completed", "created_at", "updated_at"}
	mock.ExpectQuery("SELECT id, user_id, title, completed, created_at, updated_at FROM todos WHERE user_id = ?").
		WithArgs(2).
		WillReturnRows(sqlmock.NewRows(columns).
			AddRow(2, 2, "Todo 2", false, time.Now(), time.Now()).
			AddRow(3, 2, "Todo 3", false, time.Now(), "hi")) // This will cause an error due to the wrong type

	tc := model.TodoItemCollection{DB: db}

	/// Act
	// call GetAllTodoItems on user id 2
	todos, err := tc.GetAllTodoItems(2)

	/// Assert
	///
	assert.Error(t, err, "Expected an error but got none")
	assert.Equal(t, customErr.Error(), err.Error(), "Expected a different error")
	assert.Nil(t, todos, "Expected todos to be nil on error")

	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}
}

// TestCreateTodoItem_ExecuteCorrectQuery tests that CreateTodoItem executes the correct query,
// returns the correct TodoItem data,
// especially the todo item ID, which is generated by the database,
// and CreatedAt and UpdatedAt, which is 'now', ignoring what the user gave.
func TestCreateTodoItem_ExecuteCorrectQuery(t *testing.T) {
	/// Arrange
	///
	// Create a new instance of sqlmock
	db, mock, errdb := sqlmock.New()
	if errdb != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", errdb)
	}
	defer db.Close()

	expectedTimeNow := time.Now()

	// columns := []string{"id", "user_id", "title", "completed", "created_at", "updated_at"}
	//mock.ExpectExec("INSERT INTO todos (user_id, title, completed, created_at, updated_at) VALUES (?, ?, ?, ?, ?)").
	mock.ExpectExec("INSERT INTO todos \\(user_id, title, completed, created_at, updated_at\\) VALUES \\(.+\\)").
		WithArgs(2, "Todo 2", true, expectedTimeNow, expectedTimeNow).
		WillReturnResult(sqlmock.NewResult(3, 1)) // expect id 3 to be returned

	tc := model.TodoItemCollection{DB: db}

	/// Act
	///
	todo := model.TodoItem{
		UserID:    21, // ignore what user specified, will be overwritten
		Title:     "Todo 2",
		Completed: true,                           // respect what user specified
		CreatedAt: time.Now().Add(-time.Hour * 3), // ignore what user specified, will be overwritten
		UpdatedAt: time.Now().Add(-time.Hour * 3), // ignore what user specified, will be overwritten
	}
	// call CreateTodoItem and pass the mocked db instance
	err := tc.CreateTodoItem(2, &todo) // system specified user id 2
	if err != nil {
		t.Errorf("error was not expected while creating todo item: %s", err)
	}

	/// Assert
	///
	assert.NoError(t, err, "Expected no error but got one")
	assert.Equal(t, 3, todo.ID, "Expected inserted todo ID to be returned")
	assert.Equal(t, 2, todo.UserID, "Expected user ID to be what is system specified instead of what user given")
	assert.Equal(t, "Todo 2", todo.Title)
	assert.Equal(t, true, todo.Completed, "Expected completed to follow what user given")
	assert.Equal(t, expectedTimeNow, todo.CreatedAt, "Expected created_at to be time of creation instead of what user given")
	assert.Equal(t, expectedTimeNow, todo.UpdatedAt, "Expected updated_at to be time of creation instead of what user given")

	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}
}

// TestCreateTodoItem_ReturnErrorWhenQueryError tests that MarkComplete executes the correct query,
// returns the correct TodoItem data,
// Ignored fields: UserID, Title, Completed, CreatedAt, UpdatedAt
func TestMarkComplete_ExecuteCorrectQuery(t *testing.T) {
	/// Arrange
	///
	// Create a new instance of sqlmock
	db, mock, errdb := sqlmock.New()
	if errdb != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", errdb)
	}
	defer db.Close()

	expectedTimeNow := time.Now() // expected MarkComplete() to update updated_at to now

	mock.ExpectExec("UPDATE todos SET completed = \\?, updated_at = \\? WHERE id = \\? AND user_id = \\?").
		WithArgs(true, expectedTimeNow, 2, 3).     //aiming for todo id 2, user id 3
		WillReturnResult(sqlmock.NewResult(-1, 1)) // expect impacted rows to be 1

	tc := model.TodoItemCollection{DB: db}

	/// Act
	///
	// call MarkComplete on todo item id 2, user id 3
	err := tc.MarkComplete(3, 2)
	if err != nil {
		t.Errorf("error was not expected while creating todo item: %s", err)
	}

	/// Assert
	///
	assert.NoError(t, err, "Expected no error but got one")

	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}
}

func TestDeleteTodoItem_ExecuteCorrectQuery(t *testing.T) {
	/// Arrange
	///
	// Create a new instance of sqlmock
	db, mock, errdb := sqlmock.New()
	if errdb != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", errdb)
	}
	defer db.Close()

	mock.ExpectExec("DELETE FROM todos WHERE id = \\? AND user_id = \\?").
		WithArgs(2, 3).                            //aiming for todo id 2, user id 3
		WillReturnResult(sqlmock.NewResult(-1, 1)) // expect impacted rows to be 1

	/// Act
	///
	tc := model.TodoItemCollection{DB: db}

	// call DeleteTodoItem aiming for todo id 2, user id 3
	err := tc.DeleteTodoItem(3, 2)
	if err != nil {
		t.Errorf("error was not expected while creating todo item: %s", err)
	}

	/// Assert
	///
	assert.NoError(t, err, "Expected no error but got one")

	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}
}
