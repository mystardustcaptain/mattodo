package model_test

import (
	"errors"
	"testing"
	"time"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/mystardustcaptain/mattodo/pkg/model"
	"github.com/stretchr/testify/assert"
)

// TestGetAllTodoItems_ExecuteCorrectQuery tests that GetAllTodoItems executes the correct query,
// returns the correct number of TodoItems,
// and returns the correct TodoItems data,
// and handle errors correctly.
func TestGetAllTodoItems_ExecuteCorrectQuery(t *testing.T) {
	/// Arrange
	///
	// Create a new instance of sqlmock
	db, mock, errdb := sqlmock.New()
	if errdb != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", errdb)
	}
	defer db.Close()

	columns := []string{"id", "user_id", "title", "completed", "created_at", "updated_at"}
	mock.ExpectQuery("SELECT id, user_id, title, completed, created_at, updated_at FROM todos WHERE user_id = ?").
		WithArgs(2).
		WillReturnRows(sqlmock.NewRows(columns).
			AddRow(2, 2, "Todo 2", false, time.Now(), time.Now()).
			AddRow(3, 2, "Todo 3", false, time.Now(), time.Now()))

	/// Act
	///
	// call GetAllTodoItems and pass the mocked db instance
	todos, err := model.GetAllTodoItems(db, 2)
	if err != nil {
		t.Errorf("error was not expected while getting todo items: %s", err)
	}

	/// Assert
	///
	assert.Equal(t, 2, len(todos))
	assert.NoError(t, err, "Expected no error but got one")
	assert.Equal(t, 2, todos[0].ID)
	assert.Equal(t, 2, todos[0].UserID)
	assert.Equal(t, "Todo 2", todos[0].Title)
	assert.Equal(t, false, todos[0].Completed)
	assert.Equal(t, 3, todos[1].ID)
	assert.Equal(t, 2, todos[1].UserID)
	assert.Equal(t, "Todo 3", todos[1].Title)
	assert.Equal(t, false, todos[1].Completed)

	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}
}

// TestGetAllTodoItems_ReturnNothingWhenNoTodoItems tests that GetAllTodoItems returns nothing when there are error with the query.
// It is to ensure that the error is handled correctly,
// and that the function does not return any TodoItems,
// and that the error is the expected error.
func TestGetAllTodoItems_ReturnNothingWhenQueryError(t *testing.T) {
	/// Arrange
	///
	// Create a new instance of sqlmock
	db, mock, errdb := sqlmock.New()
	if errdb != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", errdb)
	}
	defer db.Close()

	// Define a custom error
	customErr := errors.New("mock database connection error")

	mock.ExpectQuery("SELECT id, user_id, title, completed, created_at, updated_at FROM todos WHERE user_id = ?").
		WithArgs(2).
		WillReturnError(customErr)

	/// Act
	///
	// call GetAllTodoItems and pass the mocked db instance
	todos, err := model.GetAllTodoItems(db, 2)

	/// Assert
	///
	assert.Error(t, err, "Expected an error but got none")
	assert.Equal(t, customErr, err, "Expected a different error")
	assert.Nil(t, todos, "Expected todos to be nil on error")

	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}
}

// TestGetAllTodoItems_ReturnNothingWhenScanError tests that GetAllTodoItems returns nothing when there are error during scanning rows.
// It is to ensure that the error is handled correctly,
// and that the function does not return any TodoItems,
// and that the error is the expected error.
func TestGetAllTodoItems_ReturnNothingWhenScanError(t *testing.T) {
	/// Arrange
	// Create a new instance of sqlmock
	db, mock, errdb := sqlmock.New()
	if errdb != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", errdb)
	}
	defer db.Close()

	// Define a custom error
	customErr := errors.New("sql: Scan error on column index 5, name \"updated_at\": unsupported Scan, storing driver.Value type string into type *time.Time")

	columns := []string{"id", "user_id", "title", "completed", "created_at", "updated_at"}
	mock.ExpectQuery("SELECT id, user_id, title, completed, created_at, updated_at FROM todos WHERE user_id = ?").
		WithArgs(2).
		WillReturnRows(sqlmock.NewRows(columns).
			AddRow(2, 2, "Todo 2", false, time.Now(), time.Now()).
			AddRow(3, 2, "Todo 3", false, time.Now(), "hi")) // This will cause an error due to the wrong type

	/// Act
	// call GetAllTodoItems and pass the mocked db instance
	todos, err := model.GetAllTodoItems(db, 2)

	/// Assert
	///
	assert.Error(t, err, "Expected an error but got none")
	assert.Equal(t, customErr.Error(), err.Error(), "Expected a different error")
	assert.Nil(t, todos, "Expected todos to be nil on error")

	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}
}

// TestCreateTodoItem_ExecuteCorrectQuery tests that CreateTodoItem executes the correct query,
// returns the correct TodoItem data,
// especially the todo item ID, which is generated by the database,
// and CreatedAt and UpdatedAt, which is 'now', ignoring what the user gave.
func TestCreateTodoItem_ExecuteCorrectQuery(t *testing.T) {
	/// Arrange
	///
	// Create a new instance of sqlmock
	db, mock, errdb := sqlmock.New()
	if errdb != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", errdb)
	}
	defer db.Close()

	expectedTimeNow := time.Now()

	// columns := []string{"id", "user_id", "title", "completed", "created_at", "updated_at"}
	//mock.ExpectExec("INSERT INTO todos (user_id, title, completed, created_at, updated_at) VALUES (?, ?, ?, ?, ?)").
	mock.ExpectExec("INSERT INTO todos \\(user_id, title, completed, created_at, updated_at\\) VALUES \\(.+\\)").
		WithArgs(2, "Todo 2", true, expectedTimeNow, expectedTimeNow).
		WillReturnResult(sqlmock.NewResult(3, 1)) // expect id 3 to be returned

	/// Act
	///
	todo := model.TodoItem{
		UserID:    21, // ignore what user specified, will be overwritten
		Title:     "Todo 2",
		Completed: true,                           // respect what user specified
		CreatedAt: time.Now().Add(-time.Hour * 3), // ignore what user specified, will be overwritten
		UpdatedAt: time.Now().Add(-time.Hour * 3), // ignore what user specified, will be overwritten
	}
	// call CreateTodoItem and pass the mocked db instance
	err := todo.CreateTodoItem(db, 2) // system specified user id 2
	if err != nil {
		t.Errorf("error was not expected while creating todo item: %s", err)
	}

	/// Assert
	///
	assert.NoError(t, err, "Expected no error but got one")
	assert.Equal(t, 3, todo.ID, "Expected inserted todo ID to be returned")
	assert.Equal(t, 2, todo.UserID, "Expected user ID to be what is system specified instead of what user given")
	assert.Equal(t, "Todo 2", todo.Title)
	assert.Equal(t, true, todo.Completed, "Expected completed to follow what user given")
	assert.Equal(t, expectedTimeNow, todo.CreatedAt, "Expected created_at to be time of creation instead of what user given")
	assert.Equal(t, expectedTimeNow, todo.UpdatedAt, "Expected updated_at to be time of creation instead of what user given")

	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}
}

// TestCreateTodoItem_ReturnErrorWhenQueryError tests that MarkComplete executes the correct query,
// returns the correct TodoItem data,
// Ignored fields: UserID, Title, Completed, CreatedAt, UpdatedAt
func TestMarkComplete_ExecuteCorrectQuery(t *testing.T) {
	/// Arrange
	///
	// Create a new instance of sqlmock
	db, mock, errdb := sqlmock.New()
	if errdb != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", errdb)
	}
	defer db.Close()

	expectedTimeNow := time.Now()

	mock.ExpectExec("UPDATE todos SET completed = \\?, updated_at = \\? WHERE id = \\? AND user_id = \\?").
		WithArgs(true, expectedTimeNow, 2, 3).     //aiming for todo id 2, user id 3
		WillReturnResult(sqlmock.NewResult(-1, 1)) // expect impacted rows to be 1

	/// Act
	///
	todo := model.TodoItem{
		ID:        2,                              // MarkComplete is called on todo item id 2
		UserID:    45,                             // Ignore what user specified, use system specified user id 3 instead, will not be updated in the object
		Title:     "Todo 2",                       // Ignore
		Completed: false,                          // Expect to be updated to true
		CreatedAt: time.Now().Add(-time.Hour * 3), // Ignore
		UpdatedAt: time.Now().Add(-time.Hour * 3), //Expect to be updated to now
	}
	// call MarkComplete and pass the mocked db instance
	err := todo.MarkComplete(db, 3) // system specified user id 3
	if err != nil {
		t.Errorf("error was not expected while creating todo item: %s", err)
	}

	/// Assert
	///
	assert.NoError(t, err, "Expected no error but got one")
	assert.Equal(t, 2, todo.ID)
	assert.Equal(t, 45, todo.UserID) // even though user specified user id 45, the system should use user id 3 instead, and do not update the user id in the object
	assert.Equal(t, "Todo 2", todo.Title, "Expected title not updated")
	assert.Equal(t, true, todo.Completed) // status should be updated to true and updated in the object
	assert.NotEqual(t, expectedTimeNow, todo.CreatedAt, "Expected created_at not updated")
	assert.Equal(t, expectedTimeNow, todo.UpdatedAt, "Expected updated_at to be time of creation instead of what user given")

	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}
}

func TestDeleteTodoItem_ExecuteCorrectQuery(t *testing.T) {
	/// Arrange
	///
	// Create a new instance of sqlmock
	db, mock, errdb := sqlmock.New()
	if errdb != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", errdb)
	}
	defer db.Close()

	mock.ExpectExec("DELETE FROM todos WHERE id = \\? AND user_id = \\?").
		WithArgs(2, 3).                            //aiming for todo id 2, user id 3
		WillReturnResult(sqlmock.NewResult(-1, 1)) // expect impacted rows to be 1

	/// Act
	///
	tc := model.TodoItemCollection{DB: db}

	// call DeleteTodoItem aiming for todo id 2, user id 3
	err := tc.DeleteTodoItem(3, 2)
	if err != nil {
		t.Errorf("error was not expected while creating todo item: %s", err)
	}

	/// Assert
	///
	assert.NoError(t, err, "Expected no error but got one")

	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}
}
